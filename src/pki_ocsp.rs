// Copyright 2023-2026 Andreas Steffen
//
// Copyright secunet Security Networks AG
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.

use std::process::ExitCode;
use getopts::Matches;
use pki::{Command, Opt};

//
// Verifies the optional OCSP request signature generated by an OCSP requestor.
//
pub fn pki_ocsp(matches: &Matches) -> ExitCode
{
    if matches.opt_present("i") {
        let file = matches.opt_str("i").unwrap();
        println!("option: --in {}", file);
    } else {
        println!("option '--in' missing: get input from stdin");
    }

    let respond: bool = matches.opt_present("r");
    println!("respond:  {}", respond);

     let certs: Vec<String> = matches.opt_strs("c");
    for c in &certs {
         println!("option: --cert {}", c);
    }

    let certids: Vec<String> = matches.opt_strs("X");
    for i in &certids {
         println!("option: --certid {}", i);
    }

    let keys: Vec<String> = matches.opt_strs("k");
    for k in &keys {
         println!("option: --key {}", k);
    }

    let keyids: Vec<String> = matches.opt_strs("K");
    for i in &keyids {
         println!("option: --keyid {}", i);
    }

    let cacerts: Vec<String> = matches.opt_strs("C");
    for c in &cacerts {
         println!("option: --cacert {}", c);
    }

    let index_responders: Vec<String> = matches.opt_strs("x");
    for i in &index_responders {
         println!("option: --index {}", i);
    }

    if matches.opt_present("g") {
        let digest = matches.opt_str("g").unwrap();
        println!("option: --digest {}", digest);
    }

    if matches.opt_present("R") {
        let padding = matches.opt_str("R").unwrap();
        println!("option: --rsa-padding {}", padding);
    }

    let lifetime: i64 = 60 * match matches.opt_str("l") {
        Some(string) => { string.parse().unwrap() }
        None => { 0 } // minutes
    };
    println!("option: --lifetime {} seconds", lifetime);

    println!("ocsp()");
    return ExitCode::SUCCESS;
}

//
// Register the command.
//
inventory::submit!
{
    let brief: &'static[&'static str] = &[
        "[--in file] [--respond] [--cert file|--certid hex]+ [--key file|--keyid hex]+ ",
        "[--cacert file [--index file]]+",
        "[--digest md5|sha1|sha224|sha256|sha384|sha512|sha3_224|sha3_256|sha3_384|sha3_512]",
        "[--rsa-padding pkcs1|pss] [--lifetime minutes]"
    ];
    let options: &'static[Opt] = &[
        Opt { long: "help",        short: "h", arg: 0, descr: "show usage information" },
        Opt { long: "respond",     short: "r", arg: 0, descr: "respond to OCSP request with OCSP response" },
        Opt { long: "in",          short: "i", arg: 1, descr: "input file, default: stdin" },
        Opt { long: "key",         short: "k", arg: 2, descr: "path to OCSP signing private key (can be used multiple times)" },
        Opt { long: "keyid",       short: "K", arg: 2, descr: "smartcard or TPM private key object handle (can be used multiple times)" },
        Opt { long: "cert",        short: "c", arg: 2, descr: "path to OCSP signing certificate (can be used multiple times" },
        Opt { long: "certid",      short: "X", arg: 2, descr: "smartcard or TPM certificate object handle (can be used multiple times)"  },
        Opt { long: "cacert",      short: "C", arg: 2, descr: "CA certificate (can be used multiple times" },
        Opt { long: "index",       short: "x", arg: 2, descr: "OpenSSL-style index.txt to check status of certificates" },
        Opt { long: "digest",      short: "g", arg: 1, descr: "digest for signature creation, default: key-specific" },
        Opt { long: "rsa-padding", short: "R", arg: 1, descr: "padding for RSA signatures, default: pkcs1" },
        Opt { long: "lifetime",    short: "l", arg: 1, descr: "validity in minutes of the OCSP response (if missing, nextUpdate is omitted)" },
    ];
    Command::new(pki_ocsp, "o", "ocsp",
                "OCSP responder", brief, options)
}
